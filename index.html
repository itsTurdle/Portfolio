// index.js
const PROXY_BASE = 'https://api.allorigins.win/raw?url=';

async function fetchThumbnail(id) {
  const thumbUrl = `https://thumbnails.roblox.com/v1/assets?assetIds=${id}&size=768x432&format=Png&isCircular=false`;
  try {
    const res = await fetch(thumbUrl, { headers: { 'Roblox-Place-Id': id } });
    if (!res.ok) throw new Error();
    const data = await res.json();
    return data.data?.[0]?.imageUrl || null;
  } catch (e) {
    const proxyUrl = PROXY_BASE + encodeURIComponent(thumbUrl);
    try {
      const res2 = await fetch(proxyUrl);
      if (!res2.ok) throw new Error();
      const data2 = await res2.json();
      return data2.data?.[0]?.imageUrl || proxyUrl;
    } catch {
      return null;
    }
  }
}

const sleep = ms => new Promise(r => setTimeout(r, ms));
const canvas = document.getElementById('bg-canvas');
const ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

const particles = [], COUNT = 135, TH = 120, RS = 0.002, MV = 1;
let mouse = { x: null, y: null };
document.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
for (let i = 0; i < COUNT; i++) {
  const p = {
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    x0: null,
    y0: null,
    vx: (Math.random() - 0.5) * 0.5,
    vy: (Math.random() - 0.5) * 0.5,
    size: Math.random() * 2 + 1
  };
  p.x0 = p.x;
  p.y0 = p.y;
  particles.push(p);
}

function animate() {
  ctx.fillStyle = '#0f0f12';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  particles.forEach((a, i) => {
    for (let j = i + 1; j < COUNT; j++) {
      const b = particles[j];
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const d = Math.hypot(dx, dy);
      if (d < TH) {
        const alpha = 1 - d / TH;
        ctx.strokeStyle = `rgba(181,54,255,${alpha * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
    }
  });
  particles.forEach(p => {
    if (mouse.x !== null) {
      const dx = p.x - mouse.x;
      const dy = p.y - mouse.y;
      const d = Math.hypot(dx, dy);
      if (d < 100) {
        const f = (100 - d) / 100 * 0.5;
        p.vx += (dx / d) * f;
        p.vy += (dy / d) * f;
      }
    }
    p.vx += (p.x0 - p.x) * RS;
    p.vy += (p.y0 - p.y) * RS;
    const sp = Math.hypot(p.vx, p.vy);
    if (sp > MV) {
      p.vx = p.vx / sp * MV;
      p.vy = p.vy / sp * MV;
    }
    p.vx *= 0.9;
    p.vy *= 0.9;
    p.x += p.vx;
    p.y += p.vy;
    if (p.x < 0) { p.x = 0; p.vx *= -1; }
    if (p.x > canvas.width) { p.x = canvas.width; p.vx *= -1; }
    if (p.y < 0) { p.y = 0; p.vy *= -1; }
    if (p.y > canvas.height) { p.y = canvas.height; p.vy *= -1; }
    ctx.fillStyle = 'rgba(181,54,255,0.7)';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
  requestAnimationFrame(animate);
}
animate();

const API = 'https://games.roblox.com/v2/users/1914390459/games?accessFilter=Public&limit=10';
const LIMIT = 4;
async function fetchGames() {
  const res = await fetch(API, { cache: 'no-store' });
  if (!res.ok) throw `HTTP ${res.status}`;
  return (await res.json()).data;
}
function createCard(game) {
  const id = game.rootPlace.id;
  const card = document.createElement('div');
  card.className = 'card';
  const inner = document.createElement('div');
  inner.className = 'inner';
  const img = document.createElement('img');
  card.style.display = 'none';
  let resolveLoad;
  card.loadPromise = new Promise(r => resolveLoad = r);
  fetchThumbnail(id).then(remote => {
    const src = remote || 'https://via.placeholder.com/768x432?text=No+Image';
    img.src = src;
    img.onload = () => { img.style.opacity = '1'; card.style.display = ''; resolveLoad(); };
    img.onerror = () => { const ph = 'https://via.placeholder.com/768x432?text=No+Image'; img.src = ph; img.onload = () => { card.style.display = ''; resolveLoad(); }; };
  });
  inner.append(img);
  const info = document.createElement('div');
  info.className = 'info';
  const weeks = Math.floor((Date.now() - new Date(game.created).getTime()) / (1000 * 60 * 60 * 24 * 7));
  const age = weeks > 0 ? `${weeks}w ago` : `${Math.floor((Date.now() - new Date(game.created)) / 86400000)}d ago`;
  info.innerHTML = `<h3><a href=\"https://www.roblox.com/games/${id}\" target=\"_blank\">${game.name}</a></h3><p>${(game.description||'No description').slice(0,90)}</p><div class=\"age\">ðŸ•’ ${age}</div>`;
  const btn = document.createElement('a');
  btn.href = `roblox://placeId=${id}`;
  btn.className = 'btn';
  btn.textContent = 'Play';
  info.append(btn);
  inner.append(info);
  card.append(inner);
  return card;
}
async function init() {
  const grid = document.getElementById('grid');
  const games = (await fetchGames()).slice(0, LIMIT);
  const obs = new IntersectionObserver(entries => entries.forEach(({target,isIntersecting}) => isIntersecting && target.classList.add('visible')), { threshold: 0.1 });
  for (const g of games) {
    const c = createCard(g);
    grid.append(c);
    obs.observe(c);
    await c.loadPromise;
  }
  const copyBtn = document.getElementById('copyBtn');
  const copyLabel = document.getElementById('copyLabel');
  copyBtn.addEventListener('click', async () => {
    const t = copyLabel.textContent;
    if (navigator.clipboard) await navigator.clipboard.writeText(t);
    else { const i = document.createElement('input'); i.value = t; document.body.append(i); i.select(); document.execCommand('copy'); i.remove(); }
    copyLabel.textContent = 'Copied!';
    setTimeout(() => copyLabel.textContent = 'its_turdle', 1500);
  });
}
document.addEventListener('DOMContentLoaded', init);
